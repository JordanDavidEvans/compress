<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lightweight Image Compressor | WebP Optimizer</title>
  <meta name="description" content="Compress PNG, JPEG, or GIF images into WebP instantly. Drag and drop multiple files, target a 500KB size, and watch the live compression progress." />
  <meta name="keywords" content="image compressor, webp converter, compress images online, drag and drop image compressor, reduce image size" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b1021;
      --panel: #10172d;
      --accent: #6bf0c6;
      --accent-strong: #35cf9f;
      --text: #e6eefc;
      --muted: #9fb3ce;
      --border: #1f2a44;
      --shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(107, 240, 198, 0.08), transparent 25%),
        radial-gradient(circle at 80% 0%, rgba(53, 207, 159, 0.12), transparent 25%),
        radial-gradient(circle at 40% 80%, rgba(107, 240, 198, 0.12), transparent 25%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    main {
      width: min(1100px, 92vw);
      padding: 32px 0 80px;
    }

    header {
      text-align: center;
      margin-bottom: 32px;
    }

    h1 {
      font-size: clamp(2rem, 3vw + 0.5rem, 3rem);
      margin: 0;
      letter-spacing: -0.02em;
    }

    p.lede {
      color: var(--muted);
      margin: 10px auto 0;
      max-width: 700px;
      line-height: 1.6;
    }

    section.card {
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
      margin-bottom: 20px;
    }

    .settings {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      align-items: center;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }

    input[type="number"] {
      width: 110px;
      padding: 10px 12px;
      background: #0f1426;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 15px;
    }

    .dropzone {
      border: 1.5px dashed var(--border);
      border-radius: 24px;
      padding: 24px;
      text-align: center;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
    }

    .dropzone:hover,
    .dropzone.dragging {
      border-color: var(--accent);
      transform: translateY(-2px);
    }

    .dropzone input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .cta {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #041014;
      padding: 14px 20px;
      border-radius: 14px;
      font-weight: 700;
      text-decoration: none;
      margin-top: 10px;
      box-shadow: 0 14px 35px rgba(107, 240, 198, 0.25);
    }

    .small {
      display: block;
      color: var(--muted);
      margin-top: 8px;
    }

    .results {
      display: grid;
      gap: 16px;
    }

    .file-card {
      background: rgba(15, 20, 38, 0.7);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr auto;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    .file-info strong {
      font-size: 16px;
    }

    .attempts {
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 20px;
      font-weight: 600;
    }

    .status.running {
      background: rgba(107, 240, 198, 0.1);
      color: var(--accent);
    }

    .status.done {
      background: rgba(107, 240, 198, 0.2);
      color: #041014;
    }

    .status.error {
      background: rgba(255, 98, 117, 0.2);
      color: #ff6275;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: conic-gradient(from 90deg, rgba(107, 240, 198, 0.15), rgba(107, 240, 198, 0.65), rgba(107, 240, 198, 0.15));
      mask: radial-gradient(circle, transparent 60%, #000 60%);
      animation: spin 1.1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .pulse-bar {
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(107, 240, 198, 0.08), rgba(53, 207, 159, 0.18), rgba(107, 240, 198, 0.08));
      opacity: 0.25;
      animation: shimmer 1.8s ease-in-out infinite;
      transform: translateX(-120%);
      pointer-events: none;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-120%);
      }
      50% {
        transform: translateX(0%);
      }
      100% {
        transform: translateX(120%);
      }
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .button {
      border: 1px solid var(--border);
      background: #0f1426;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    .button.primary {
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #041014;
      border: none;
      box-shadow: 0 12px 30px rgba(107, 240, 198, 0.2);
    }

    footer {
      color: var(--muted);
      margin-top: 40px;
      line-height: 1.6;
    }

    @media (max-width: 640px) {
      .file-card {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Lightning-Fast WebP Image Compressor</h1>
      <p class="lede">Drag and drop or select multiple images to instantly convert them into efficient WebP files. The compressor targets a 500KB default size, trims resolution in smart steps, and shows every attempt with a live animation.</p>
    </header>

    <section class="card" aria-labelledby="settings-title">
      <div class="settings">
        <div>
          <label id="settings-title" for="target-range">Target size (KB)</label>
          <div class="controls">
            <input id="target-range" type="range" min="100" max="3000" step="50" value="500" aria-describedby="target-help" />
            <input id="target-input" type="number" min="50" max="5000" step="10" value="500" aria-label="Target size in kilobytes" />
          </div>
          <small id="target-help" class="small">Default is 500KB. The compressor will keep 97% WebP quality and reduce resolution until the file drops below your target.</small>
        </div>
        <div>
          <div class="dropzone" id="dropzone" role="button" tabindex="0" aria-label="Drop images here or click to select">
            <input id="file-input" type="file" accept="image/*" multiple aria-label="Upload images" />
            <div>
              <strong>Drop images or click to select</strong>
              <div class="small">PNG, JPG, GIF, TIFF, HEIC: everything becomes WebP on the fly.</div>
              <span class="cta">Start compressing instantly</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="progress-title">
      <h2 id="progress-title" style="margin: 0 0 12px;">Compression progress</h2>
      <div class="results" id="results" aria-live="polite"></div>
      <div class="small">Need help? Drop several images at once—each runs through the WebP converter with live status. Keep the tab open to download the compressed versions.</div>
    </section>

    <footer>
      <p>Why WebP? Google-friendly WebP keeps photos crisp while cutting bandwidth, improving Core Web Vitals, and boosting SEO. This tool runs entirely in your browser—no uploads, no waiting—making it ideal for performance-focused sites and privacy-first workflows.</p>
      <p>Tip: Use the range slider to tune your target size. The compressor begins at 97% WebP quality and progressively scales down the resolution in 10% steps until it meets your goal.</p>
    </footer>
  </main>

  <script>
    const targetRange = document.getElementById("target-range");
    const targetInput = document.getElementById("target-input");
    const dropzone = document.getElementById("dropzone");
    const fileInput = document.getElementById("file-input");
    const results = document.getElementById("results");

    const syncTargetInputs = (value) => {
      const sanitized = Math.min(Math.max(Number(value) || 500, 50), 5000);
      targetRange.value = sanitized;
      targetInput.value = sanitized;
      return sanitized;
    };

    targetRange.addEventListener("input", (e) => syncTargetInputs(e.target.value));
    targetInput.addEventListener("input", (e) => syncTargetInputs(e.target.value));

    const formatKB = (bytes) => `${(bytes / 1024).toFixed(1)} KB`;

    const dataURLToBlob = (dataURL) => {
      const [header, data] = dataURL.split(",");
      const mimeMatch = header.match(/:(.*?);/);
      const mime = mimeMatch ? mimeMatch[1] : "image/webp";
      const binary = atob(data);
      const array = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        array[i] = binary.charCodeAt(i);
      }
      return new Blob([array], { type: mime });
    };

    const updateCard = (card, { status, attemptsText, extra, blob, fileName }) => {
      const statusEl = card.querySelector(".status");
      const attemptsEl = card.querySelector(".attempts");
      const actionsEl = card.querySelector(".actions");
      const pulse = card.querySelector(".pulse-bar");

      statusEl.className = `status ${status}`;
      statusEl.innerHTML = status === "running" ? `<span class="spinner"></span>Compressing` : status === "done" ? "Compression ready" : "Error";
      attemptsEl.textContent = attemptsText;
      pulse.style.display = status === "running" ? "block" : "none";

      if (blob && fileName) {
        const url = URL.createObjectURL(blob);
        actionsEl.innerHTML = `
          <a class="button primary" href="${url}" download="${fileName}">Download WebP</a>
          <button class="button" type="button" data-action="reset">Clear</button>
        `;
      } else {
        actionsEl.innerHTML = `<button class="button" type="button" data-action="reset">Cancel</button>`;
      }
    };

    const createFileCard = (fileName, targetBytes) => {
      const card = document.createElement("article");
      card.className = "file-card";
      card.innerHTML = `
        <div class="pulse-bar" aria-hidden="true"></div>
        <div class="file-info">
          <strong>${fileName}</strong>
          <div class="attempts">Preparing to compress at 97% quality to ${Math.round(targetBytes / 1024)} KB…</div>
        </div>
        <div class="actions">
          <span class="status running"><span class="spinner"></span>Compressing</span>
        </div>
      `;
      results.prepend(card);
      return card;
    };

    const compressImage = (file) => {
      const targetKB = syncTargetInputs(targetInput.value);
      const targetBytes = targetKB * 1024;
      const card = createFileCard(file.name, targetBytes);

      const img = new Image();
      const reader = new FileReader();

      reader.onload = (event) => {
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);

      img.onload = async () => {
        let scale = 1;
        let attempt = 0;
        let lastSize = file.size;
        let blob = null;

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        while (scale > 0.05) {
          attempt += 1;
          const width = Math.max(1, Math.floor(img.naturalWidth * scale));
          const height = Math.max(1, Math.floor(img.naturalHeight * scale));
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);

          const dataUrl = canvas.toDataURL("image/webp", 0.97);
          blob = dataURLToBlob(dataUrl);
          lastSize = blob.size;

          updateCard(card, {
            status: "running",
            attemptsText: `Attempt ${attempt}: ${width}×${height} • ${formatKB(lastSize)} (${Math.round(scale * 100)}% of original)`
          });

          if (lastSize <= targetBytes) {
            break;
          }
          scale *= 0.9;
          await new Promise((resolve) => setTimeout(resolve, 80));
        }

        if (blob) {
          if (lastSize > targetBytes) {
            updateCard(card, {
              status: "error",
              attemptsText: `Stopped after ${attempt} attempts. Closest size: ${formatKB(lastSize)}.`
            });
          } else {
            const cleanName = file.name.replace(/\.[^.]+$/, "");
            const outName = `${cleanName || "image"}-compressed.webp`;
            updateCard(card, {
              status: "done",
              attemptsText: `Finished in ${attempt} attempts. Final size: ${formatKB(lastSize)} (≤ ${targetKB} KB).`,
              blob,
              fileName: outName,
            });
          }
        }
      };

      img.onerror = () => {
        updateCard(card, {
          status: "error",
          attemptsText: "Could not read this image. Please try another file."
        });
      };
    };

    const handleFiles = (fileList) => {
      const files = Array.from(fileList).filter((file) => file.type.startsWith("image/"));
      if (!files.length) return;
      files.forEach((file) => compressImage(file));
    };

    dropzone.addEventListener("dragover", (event) => {
      event.preventDefault();
      dropzone.classList.add("dragging");
    });

    dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragging"));

    dropzone.addEventListener("drop", (event) => {
      event.preventDefault();
      dropzone.classList.remove("dragging");
      handleFiles(event.dataTransfer.files);
    });

    dropzone.addEventListener("click", () => fileInput.click());
    dropzone.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        fileInput.click();
      }
    });

    fileInput.addEventListener("change", (event) => {
      handleFiles(event.target.files);
      fileInput.value = "";
    });

    results.addEventListener("click", (event) => {
      const action = event.target.getAttribute("data-action");
      if (action === "reset") {
        const card = event.target.closest(".file-card");
        card?.remove();
      }
    });
  </script>
</body>
</html>
